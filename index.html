<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    Hexo</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay=""
             poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="Hexo"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>

    
      
        

<article id="post-js-node" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/09/20/js-node/">js-node</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/09/20/js-node/" class="article-date">
  <time datetime="2019-09-20T09:40:34.000Z" itemprop="datePublished">2019-09-20</time>
</a>
        
      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><h2 id="1-1两大编程思想："><a href="#1-1两大编程思想：" class="headerlink" title="1.1两大编程思想："></a>1.1两大编程思想：</h2><h3 id="1、面向过程"><a href="#1、面向过程" class="headerlink" title="1、面向过程"></a>1、面向过程</h3><p>​    <strong>面向过程：POP(Process-oriented programming)</strong></p>
<blockquote>
<p>​    面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</p>
</blockquote>
<h3 id="2、面向对象"><a href="#2、面向对象" class="headerlink" title="2、面向对象"></a>2、面向对象</h3><p>​    <strong>面向对象：OOP (Object Oriented Programming)</strong></p>
<blockquote>
<p>​    面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。</p>
</blockquote>
<p><strong>面向对象和过程区别</strong></p>
<p>​        面向过程：小项目</p>
<p>​        面向对象：多人合作大项目x</p>
<h2 id="1-2面向对象三大特性"><a href="#1-2面向对象三大特性" class="headerlink" title="1.2面向对象三大特性"></a>1.2面向对象三大特性</h2><ul>
<li>封装性</li>
<li>继承性</li>
<li>多态性【可以放到一起，也可以单独拿下来，坏了换哪个不影响其他的】</li>
</ul>
<h2 id="面向对象和过程的优缺点"><a href="#面向对象和过程的优缺点" class="headerlink" title="面向对象和过程的优缺点"></a>面向对象和过程的优缺点</h2><p>​    <strong>面向过程：</strong></p>
<p>​        优点：性能比面向对象高，步骤练习紧密</p>
<p>​        缺点：不好维护，不易多次使用及扩展        </p>
<p>​    面向对象：</p>
<p>​        优点：易维护，可复用，可扩展，灵活性高</p>
<p>​        缺点性能没有面向过程高</p>
<h1 id="ES6中的类和对象"><a href="#ES6中的类和对象" class="headerlink" title="ES6中的类和对象"></a>ES6中的类和对象</h1><p>类是在ES6中新加进入的，学会区分类和对象的概念，</p>
<p><strong>类：抽象</strong></p>
<p>​    类模拟抽象的，泛指的，对象是具体的</p>
<p>​    面向对象模拟现实世界，更贴近实际生活，生活照分为抽象事物和具体事物</p>
<p>​    比如：手机【两层含义：具体某个手机，和笼统的概念手机】</p>
<p>​    1、抽取，把对象的属性和行为封装成一个类</p>
<p>​    2、对类进行实例化, 获取类的对象</p>
<p><strong>对象：具体</strong></p>
<p>​    现实生活中：万物皆对象，对象是一个具体的事物，看得见摸得着的实物。例如，一本书、一辆汽车、一个人可以是“对象”</p>
<p>​    在JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。</p>
<p><strong>对象是由属性和方法组成的：</strong></p>
<p>​    属性：事物的特征，在对象中用属性来表示（常用名词）</p>
<p>​    方法：事物的行为，在对象中用方法来表示（常用动词）</p>
<p><strong>面向对象的思维特点:</strong></p>
<p>​     1.抽取（抽象）对象共用的属性和行为组织(封装)成一个类(模板)</p>
<p>​     2.对类进行实例化, 获取类的对象【new】</p>
<h2 id="类class"><a href="#类class" class="headerlink" title="类class"></a>类class</h2><blockquote>
<p>在ES6中新增加了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象。【构造函数实例化对象】</p>
</blockquote>
<ul>
<li>类抽象了对象的公共部分，它泛指某一大类（class）</li>
<li>对象特指某一个，通过类实例化一个具体的对象</li>
</ul>
<h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法：<span class="class"><span class="keyword">class</span> 类名 </span>&#123;&#125;【构造函数语法糖】</span><br><span class="line"></span><br><span class="line">注意类名首字母大写</span><br><span class="line"></span><br><span class="line">类要抽取公共属性方法，定义一个类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> Star();</span><br><span class="line">类就是构造函数的语法糖</span><br></pre></td></tr></table></figure>

<h2 id="类constructor构造函数"><a href="#类constructor构造函数" class="headerlink" title="类constructor构造函数"></a>类constructor构造函数</h2><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span> (uname,age)&#123;</span><br><span class="line">		<span class="keyword">this</span>.uname = uname;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">注意：类里面的方法不带<span class="function"><span class="keyword">function</span>，直接写既可</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">类里面要有属性方法，属性方法要是想放到类里面，我们用<span class="title">constructor</span>构造器</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">构造函数作用：接收参数，返回实例对象，<span class="title">new</span>的时候主动执行，主要放一些公共的属性</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>constructor() 方法是类的构造函数(默认方法)，用于传递参数,返回实例对象，通过new命令生成对象实例时，自动调用该方法。</p>
<p>注意：每个类里面一定有构造函数，如果没有显示定义, 类内部会自动给我们创建一个constructor() ，</p>
<p>注意：this代表当前实例化对象，谁new就代表谁</p>
</blockquote>
<h2 id="类添加方法"><a href="#类添加方法" class="headerlink" title="类添加方法"></a>类添加方法</h2><p>语法：<strong>注意方法和方法之间不能加逗号</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">constructor</span> () &#123;&#125; <span class="comment">//里面写属性</span></span><br><span class="line"></span><br><span class="line">	sing () &#123;&#125; <span class="comment">//方法</span></span><br><span class="line"></span><br><span class="line">	tiao () &#123;&#125;<span class="comment">//方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123; <span class="keyword">constructor</span>()&#123;&#125;   方法名()&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">注意：类中定义属性，调用方法都得用<span class="keyword">this</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：方法之间不能加逗号分隔，同时方法不需要添加function 关键字</p>
</blockquote>
<p><strong>总结：类有对象的公共属性和方法，用class创建，class里面包含constructor和方法，我们把公共属性放到constructor里面，把公共方法直接往后写既可，但是注意不要加逗号</strong></p>
<h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a><strong>extends</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line"></span><br><span class="line">​	<span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">注意：是子类继承父类</span><br></pre></td></tr></table></figure>

<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a><strong>super关键字</strong></h2><p>我们应用的过程中会遇到父类子类都有的属性，此时，没必要再写一次，可以直接调用父类的方法就可以了</p>
<p><u>super关键字用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数</u></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当子类没有constructor的时候可以随意用父类的，但是如果子类也含有的话，constructor会返回实例，this的指向不同，不可以再直接使用父类的东西</span><br></pre></td></tr></table></figure>

<p><strong>调用父类构造函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class F &#123; constructor(name, age)&#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">class S extends F &#123; constructor (name, age) &#123; super(name,age); &#125; &#125;</span><br><span class="line"></span><br><span class="line">注意: 子类在构造函数中使用super, 必须放到this 前面(必须先调用父类的构造方法,在使用子类构造方法）</span><br></pre></td></tr></table></figure>

<p><strong>调用父类普通函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class F &#123; constructor(name, age)&#123;&#125; say () &#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line">class S extends F &#123; constructor (name, age) &#123; super(name,age); &#125; say () &#123; super.say() &#125; &#125;</span><br><span class="line"></span><br><span class="line">注意：如果子类也有相同的方法，优先指向子类，就近原则</span><br></pre></td></tr></table></figure>

<p><strong>总结：super调用父类的属性和方法，那么查找属性和方法的原则就近原则</strong></p>
<h2 id="三个注意点"><a href="#三个注意点" class="headerlink" title="三个注意点"></a>三个注意点</h2><ul>
<li>在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象.</li>
<li>类里面的共有属性和方法一定要加this使用.【this，对象调用属性和方法】按钮练习</li>
<li>类里面的this指向问题. </li>
<li>constructor 里面的this指向实例对象, 方法里面的this 指向这个方法的调用者</li>
</ul>
<p>// 构造函数中的this代表当前实例对象// 普通方法里面的this代表的是，调用者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Button &#123;</span><br><span class="line"></span><br><span class="line">	constructor () &#123;</span><br><span class="line">		var btn = document.querySelector(&apos;input&apos;);</span><br><span class="line">		btn.onclick = this.cli;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cli () &#123;</span><br><span class="line">		console.log(&apos;点击了&apos;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var anniu = new Button();</span><br></pre></td></tr></table></figure>

<h2 id="类里面的this指向"><a href="#类里面的this指向" class="headerlink" title="类里面的this指向"></a>类里面的this指向</h2><ul>
<li><p>构造函数的this指向实例对象</p>
</li>
<li><p>普通函数的this是调用者，谁调用this是谁</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"点击"</span>&gt;</span><br><span class="line"><span class="keyword">var</span> that;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">F</span> </span>&#123;</span><br><span class="line">		<span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">			<span class="comment">// console.log(this);</span></span><br><span class="line">			that = <span class="keyword">this</span>;</span><br><span class="line">			<span class="keyword">this</span>.btn = <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>);</span><br><span class="line">			<span class="keyword">this</span>.btn.onclick = <span class="keyword">this</span>.cli;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cli () &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		say () &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> obj = <span class="keyword">new</span> F(<span class="string">'刘德华'</span>,<span class="number">22</span>);</span><br></pre></td></tr></table></figure>

<h1 id="tab栏案例"><a href="#tab栏案例" class="headerlink" title="tab栏案例"></a>tab栏案例</h1><p>this执行==》构造函数，new的对象，方法：this,调用者</p>
<p><strong>面向对象版tab 栏切换</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>tab栏切换的主要思路是：</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>点击当前li 添加liactive 类其余li移除类</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>根据当前li 的索引号当前section 添加类，其余section 删除类</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>这里可以把添加放入切换函数里面</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>新增一个清除类函数，专门移除其余li和section 类</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>注意里面<span class="keyword">this</span> 指向问题</span><br></pre></td></tr></table></figure>

<p><strong>面向对象版tab 栏切换添加功能</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.点击+ 可以实现添加新的选项卡和内容</span><br><span class="line"></span><br><span class="line">2.第一步: 创建新的选项卡li 和新的内容section</span><br><span class="line"></span><br><span class="line">3.第二步: 把创建的两个元素追加到对应的父元素中.</span><br><span class="line"></span><br><span class="line">4.以前的做法:  动态创建元素createElement, 但是元素里面内容较多, 需要innerHTML赋值,在appendChild追加到父元素里面.</span><br><span class="line"></span><br><span class="line">5.现在高级做法:   利用insertAdjacentHTML() 可以直接把字符串格式元素添加到父元素中</span><br><span class="line"></span><br><span class="line">6.appendChild不支持追加字符串的子元素, insertAdjacentHTML支持追加字符串的元素</span><br><span class="line"></span><br><span class="line">7.insertAdjacentHTML(追加的位置,‘要追加的字符串元素’)  </span><br><span class="line"></span><br><span class="line">8.追加的位置有: beforeend插入元素内部的最后一个子节点之后</span><br><span class="line"></span><br><span class="line">9.该方法地址:  https://developer.mozilla.org/zh-CN/docs/Web/API/Element/insertAdjacentHTML</span><br></pre></td></tr></table></figure>

<h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><p><strong>ES5</strong></p>
<h2 id="构造函数和原形"><a href="#构造函数和原形" class="headerlink" title="构造函数和原形"></a>构造函数和原形</h2><p>在典型的OOP 的语言中（如Java），都存在类的概念，类就是对象的模板，对象就是类的实例，但在ES6之前，JS 中并没用引入类的概念。</p>
<p>ES6，全称ECMAScript6.0 ，2015.06 发版。但是目前浏览器的JavaScript 是ES5 版本，大多数高版本的浏览器也支持ES6，不过只实现了ES6 的部分特性和功能。</p>
<p>在ES6之前，对象不是基于类创建的，而是用一种称为构建函数的特殊函数来定义对象和它们的特征。</p>
<h2 id="创建对象可以通过以下三种方式："><a href="#创建对象可以通过以下三种方式：" class="headerlink" title="创建对象可以通过以下三种方式："></a>创建对象可以通过以下三种方式：</h2><ul>
<li>对象字面量</li>
<li>new Object()【构造函数】</li>
<li>自定义构造函数</li>
</ul>
<h1 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与<span class="keyword">new</span>一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在JS 中，使用构造函数时要注意以下两点：</strong></p>
<p>如果用new，就是构造函数，否则就是普通函数</p>
<p>1.构造函数用于创建某一类对象，其首字母要大写（人为规定，不是规则，为了好区分）</p>
<p>2.构造函数要和new 一起使用才有意义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">练习判断构造函数还是普通函数</span><br></pre></td></tr></table></figure>

<p><strong>new在执行时会做四件事情</strong></p>
<ol>
<li>在内存中创建一个新的空对象。</li>
<li>让this指向这个新的对象。</li>
<li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li>
<li>返回这个新对象（所以构造函数里面不需要return）。</li>
</ol>
<h2 id="静态成员和实例成员"><a href="#静态成员和实例成员" class="headerlink" title="静态成员和实例成员"></a>静态成员和实例成员</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的this 上添加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。</span><br></pre></td></tr></table></figure>

<ul>
<li>静态成员：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问</li>
<li>实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">uname, age</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.uname = uname;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> obj = <span class="keyword">new</span> Person(<span class="string">'张三丰'</span>,<span class="number">22</span>);	</span><br><span class="line">	<span class="built_in">console</span>.log(obj.uname);  <span class="comment">//实例成员</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// console.log( Person.uname );</span></span><br><span class="line">	Person.leibie = <span class="string">'人'</span>;   <span class="comment">//静态成员</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(Person.leibie);</span><br><span class="line">	<span class="built_in">console</span>.log(obj.leibie);</span><br></pre></td></tr></table></figure>

<p><strong>构造函数小问题：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当实例化对象的时候，属性好理解，属性名属性值，那么方法是函数，函数是复杂数据类型</span><br><span class="line"></span><br><span class="line">那么保存的时候是保存地址，又指向函数，而每创建一个对象，都会有一个函数，每个函数都得开辟一个内</span><br><span class="line"></span><br><span class="line">存空间，此时浪费内存了，那么如何节省内存呢，我们需要用到原型</span><br><span class="line"></span><br><span class="line">方法放到构造函数里面，如果多次实例化，会浪费内存</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Star (uname, age) &#123;</span><br><span class="line">	this.uname = uname;</span><br><span class="line">	this.age = age;</span><br><span class="line">	this.sing = function () &#123;</span><br><span class="line">		console.log(this.name + &apos;在唱歌&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ldh = new Star(&apos;周星驰&apos;, 22);</span><br><span class="line">var ldh = new Star(&apos;刘德华&apos;, 22);</span><br></pre></td></tr></table></figure>

<h2 id="构造函数原型prototype"><a href="#构造函数原型prototype" class="headerlink" title="构造函数原型prototype"></a>构造函数原型prototype</h2><p>什么是原型对象：就是一个属性，是构造函数的属性，这个属性是一个对象，我们也称呼，prototype 为原型对象。</p>
<p>每一个构造<strong>函数</strong>都有一个属性，prototype.</p>
<p>（但 Function.prototype 除外，它是函数对象，但它很特殊，他没有prototype属性（前面说道函数对象都有prototype属性））</p>
<p>作用：是为了共享方法，从而达到节省内存</p>
<p><strong>注意：每一个构造函数都有prototype属性</strong></p>
<p>例如：大家来学校上学，有的开车，有的汽车，有的开飞机，等等，此时浪费，那么准备一个大巴车，方便有节省</p>
<blockquote>
<p>构造函数通过原型分配的函数是所有对象所共享的。</p>
<p>JavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。我们可以把那些不变的方法，直接定义在prototype 对象上，这样所有对象的实例就可以共享这些方法。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Star</span> (<span class="params">uname, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">​		<span class="keyword">this</span>.uname = uname;</span><br><span class="line">​		<span class="keyword">this</span>.age = age;</span><br><span class="line">​		<span class="comment">// this.sing = function () &#123;</span></span><br><span class="line">​		<span class="comment">// 	console.log(this.name + '在唱歌');</span></span><br><span class="line">​		<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">​	&#125;</span><br><span class="line">​	Star.prototype.sing = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">​		<span class="built_in">console</span>.log(<span class="keyword">this</span>.uname + <span class="string">'在唱歌'</span>);</span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">var</span> zxc = <span class="keyword">new</span> Star(<span class="string">'周星驰'</span>, <span class="number">22</span>);</span><br><span class="line">​	<span class="keyword">var</span> ldh = <span class="keyword">new</span> Star(<span class="string">'刘德华'</span>, <span class="number">22</span>);</span><br><span class="line">​	<span class="comment">// console.log( Star.prototype );</span></span><br><span class="line">​	ldh.sing();</span><br><span class="line">​	zxc.sing();</span><br></pre></td></tr></table></figure>

<p><strong>总结：所有的公共属性写到构造函数里面，所有的公共方法写到原型对象里面</strong></p>
<p> 疑问：为何创建一个对象，都可以自动的跑到原型对象上找方法</p>
<p>因为每一个对象都有一个属性，对象原型，执行原型对象</p>
<h2 id="对象原型：proto"><a href="#对象原型：proto" class="headerlink" title="对象原型：proto"></a>对象原型：<strong><strong>proto</strong></strong></h2><p>主要作用：指向prototype</p>
<p>构造函数和原型对象都会有一个属性<strong>proto</strong> 指向构造函数的prototype 原型对象，之所以我们对象可以使用构造函数prototype 原型对象的属性和方法，就是因为对象有<strong>proto</strong> 原型的存在。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 注意：____proto____是一个非标准属性，不可以拿来赋值或者设置【只读属性】</span><br><span class="line">&gt; <span class="number">1.</span>____proto____对象原型和原型对象prototype 是等价的</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="number">2.</span>____proto____对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>【每一个构造函数都有：原型对象】</p>
<p>【每一个实例对象都有：对象原型】</p>
<h2 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor  构造函数"></a>constructor  构造函数</h2><blockquote>
<p><u><strong>记录是哪个构造函数创建出来的</strong></u></p>
<p>指回构造函数本身</p>
</blockquote>
<p>原型（<strong>proto</strong>）和构造函数（prototype）原型对象里面都有一个属性constructor属性，constructor 我们称为构造函数，因为它指回<strong>构造函数本身</strong>。constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个constructor 指向原来的构造函数。</p>
<p><strong>总结：constructor  主要作用可以指回原来的构造函数</strong></p>
<p><img src="E:%5Cnewlife%5C%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6%5Cjs%E9%AB%98%E7%BA%A7%5Cjs%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0%5C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%85%B3%E7%B3%BB.jpg" alt="构造函数，原型对象，对象实例关系"></p>
<p><strong>思考：如果传入一个对象给原型对象添加方法呢</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Star.prototype = &#123;</span><br><span class="line">    sing : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    dance: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">此时会覆盖原先prototype中的内容，传入一个新的对象，那么此时就不知道构造函数是哪个了</span><br><span class="line">所以我们要指回构造函数：<span class="keyword">constructor</span>：构造函数</span><br></pre></td></tr></table></figure>

<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">作用：提供一个成员的查找机制，或者查找规则</span><br></pre></td></tr></table></figure>

<p><img src="E:%5Cnewlife%5Cprogress%5Cjs%E9%AB%98%E7%BA%A7%5Cday2%5Cday2%5C%E7%AC%94%E8%AE%B01%E3%80%812%5C%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg" alt="原型链"></p>
<h2 id="JavaScript-的成员查找机制-规则"><a href="#JavaScript-的成员查找机制-规则" class="headerlink" title="JavaScript 的成员查找机制(规则)"></a>JavaScript 的成员查找机制(规则)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。</span><br><span class="line"></span><br><span class="line">如果没有就查找它的原型（也就是__proto__指向的prototype 原型对象）。</span><br><span class="line"></span><br><span class="line">如果还没有就查找原型对象的原型（Object的原型对象）。</span><br><span class="line"></span><br><span class="line">依此类推一直找到Object 为止（null）。</span><br><span class="line"></span><br><span class="line">__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</span><br><span class="line"></span><br><span class="line">// console.log(Star.prototype.__proto__.__proto__);</span><br><span class="line">// console.log(Object.prototype);</span><br></pre></td></tr></table></figure>

<h2 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a>扩展内置对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">console.log( Array.prototype );</span><br><span class="line">	// 添加求和方法</span><br><span class="line">	Array.prototype.sum = function () &#123;</span><br><span class="line">		var sum = 0;</span><br><span class="line">		for (var i = 0; i &lt; this.length; i++) &#123;</span><br><span class="line">			sum += this[i];</span><br><span class="line">		&#125;</span><br><span class="line">		return sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var arr = [1,2,3];</span><br><span class="line">	console.log( arr.sum() );</span><br><span class="line"></span><br><span class="line">	var newArr = [6,7,8,9];</span><br><span class="line">	console.log( newArr.sum() );</span><br></pre></td></tr></table></figure>

<p>构造函数：function Fn () {}</p>
<p><strong>属性写到构造函数里面，方法写到构造函数的原型对象里面</strong></p>
<p>原型对象：每一个构造函数都有原型对象【prototype】【作用是用来保存方法】</p>
<p>对象原型：每一个对象都有一个对象原型（原型）【<strong><strong>proto</strong></strong>】【作用是指向原型对象】</p>
<p>constructor：指向构造函数</p>
<p>原型链：作用是查找属性或者方法方向，机制</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ES6之前并没有给我们提供extends 继承。我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call()</span><br><span class="line"></span><br><span class="line">调用这个函数, 并且修改函数运行时的this 指向</span><br><span class="line"></span><br><span class="line">fun.call(thisArg, arg1, arg2, ...);call把父类的this指向子类</span><br><span class="line"></span><br><span class="line">thisArg ：当前调用函数this 的指向对象</span><br><span class="line"></span><br><span class="line">arg1，arg2：传递的其他参数</span><br></pre></td></tr></table></figure>

<p><strong>利用构造函数实现子类的继承：</strong></p>
<h2 id="属性的继承"><a href="#属性的继承" class="headerlink" title="属性的继承"></a><strong>属性的继承</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Father (uname,age) &#123;</span><br><span class="line">			// this指向父类的实例对象</span><br><span class="line">			this.uname = uname;</span><br><span class="line">			this.age = age;</span><br><span class="line">			// 只要把父类的this指向子类的this既可</span><br><span class="line">		&#125;</span><br><span class="line">		function Son (uname, age,score) &#123;</span><br><span class="line">			// this指向子类构造函数</span><br><span class="line">			// this.uname = uname;</span><br><span class="line">			// this.age = age;</span><br><span class="line">			// Father(uname,age);</span><br><span class="line">			Father.call(this,uname,age);</span><br><span class="line">			this.score = score;</span><br><span class="line">		&#125;</span><br><span class="line">		Son.prototype.sing = function () &#123;</span><br><span class="line">			console.log(this.uname + &apos;唱歌&apos;)</span><br><span class="line">		&#125;</span><br><span class="line">		var obj = new Son(&apos;刘德华&apos;,22,99);</span><br><span class="line">		console.log(obj.uname);</span><br><span class="line">		console.log(obj.score);</span><br><span class="line">		obj.sing();</span><br></pre></td></tr></table></figure>

<h2 id="方法的继承："><a href="#方法的继承：" class="headerlink" title="方法的继承："></a><strong>方法的继承：</strong></h2><p><strong>实现方法把父类的实例对象保存给子类的原型对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。核心原理：</span><br><span class="line"></span><br><span class="line">①将子类所共享的方法提取出来，让子类的prototype 原型对象= new 父类()  </span><br><span class="line"></span><br><span class="line">②本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象</span><br><span class="line"></span><br><span class="line">③将子类的constructor</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function Father () &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		Father.prototype.chang = function () &#123;</span><br><span class="line">			console.log(&apos;唱歌&apos;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		function Son () &#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		// Son.prototype = Father.prototype;</span><br><span class="line">		Son.prototype = new Father();</span><br><span class="line">		var obj = new Son();</span><br><span class="line">		obj.chang();</span><br><span class="line"></span><br><span class="line">		Son.prototype.score = function () &#123;</span><br><span class="line">			console.log(&apos;考试&apos;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// obj.score();</span><br><span class="line">		// console.log(Son.prototype);</span><br><span class="line">		console.log(Father.prototype);</span><br></pre></td></tr></table></figure>

<p><strong>注意：一定要让Son指回构造函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">实现继承后，让Son指回原构造函数</span><br><span class="line"></span><br><span class="line">Son.prototype = new Father();</span><br><span class="line"></span><br><span class="line">Son.prototype.constructor = Son;</span><br></pre></td></tr></table></figure>

<p><strong>总结：用构造函数实线属性继承，用原型对象实线方法继承</strong></p>
<h1 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class本质还是function</span><br><span class="line"></span><br><span class="line">类的所有方法都定义在类的prototype属性上</span><br><span class="line"></span><br><span class="line">类创建的实例,里面也有__proto__ 指向类的prototype原型对象</span><br><span class="line"></span><br><span class="line">所以ES6的类它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</span><br><span class="line"></span><br><span class="line">所以ES6的类其实就是语法糖.</span><br><span class="line"></span><br><span class="line">语法糖:语法糖就是一种便捷写法.   简单理解, 有两种方法可以实现同样的功能, 但是一种写法更加清晰、方便,那么这个方法就是语法糖</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Star &#123;&#125;</span><br><span class="line">console.log( typeof Star );</span><br><span class="line">var obj = new Star();</span><br><span class="line">console.log(obj.__proto__);</span><br><span class="line">console.log(Star.prototype);</span><br></pre></td></tr></table></figure>

<h1 id="ES5-中的新增方法"><a href="#ES5-中的新增方法" class="headerlink" title="ES5 中的新增方法"></a>ES5 中的新增方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ES5 中给我们新增了一些方法，可以很方便的操作数组或者字符串，这些方法主要包括：</span><br><span class="line"></span><br><span class="line">数组方法</span><br><span class="line"></span><br><span class="line">字符串方法</span><br></pre></td></tr></table></figure>

<h2 id="数组方法："><a href="#数组方法：" class="headerlink" title="数组方法："></a>数组方法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">迭代(遍历)方法：forEach()、map()、filter()、some()、every()；</span><br><span class="line"></span><br><span class="line">这些方法都是遍历数组的</span><br></pre></td></tr></table></figure>

<p><strong>forEach()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array.forEach(function(currentValue, index, arr))</span><br><span class="line"></span><br><span class="line">currentValue：数组当前项的值</span><br><span class="line">index：数组当前项的索引</span><br><span class="line">arr：数组对象本身</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;red&apos;,&apos;blue&apos;,&apos;yellow&apos;,&apos;orange&apos;];</span><br><span class="line"></span><br><span class="line">arr.forEach(function (elm,i,arrAbc) &#123;</span><br><span class="line">	console.log(elm,i,arrAbc);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>filter()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">array.filter(function(currentValue, index, arr))</span><br><span class="line"></span><br><span class="line">filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素,主要用于筛选数组</span><br><span class="line"></span><br><span class="line">注意它直接返回一个新数组</span><br><span class="line"></span><br><span class="line">currentValue: 数组当前项的值</span><br><span class="line"></span><br><span class="line">index：数组当前项的索引</span><br><span class="line"></span><br><span class="line">arr：数组对象本身回调函数里面添加return添加返回条件</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [100,66,99,123,333,33,44,66];</span><br><span class="line">	var reArr = arr.filter(function (elm, a, n) &#123;</span><br><span class="line"></span><br><span class="line">	// console.log(elm,a, n);</span><br><span class="line">	return elm % 2 == 0;</span><br><span class="line"></span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	console.log(reArr);</span><br></pre></td></tr></table></figure>

<p><strong>some()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">array.some(function(currentValue, index, arr)) 【注意：找到或者满足条件立刻停止】</span><br><span class="line"></span><br><span class="line">some() 方法用于检测数组中的元素是否满足指定条件. 通俗点查找数组中是否有满足条件的元素</span><br><span class="line"></span><br><span class="line">注意它返回值是布尔值, 如果查找到这个元素, 就返回true , 如果查找不到就返回false.</span><br><span class="line"></span><br><span class="line">如果找到第一个满足条件的元素,则终止循环. 不在继续查找.</span><br><span class="line"></span><br><span class="line">currentValue: 数组当前项的值index：数组当前项的索引</span><br><span class="line"></span><br><span class="line">arr：数组对象本身</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [100,200,300,400];</span><br><span class="line">var re = arr.some(function (elm,i,arr) &#123;</span><br><span class="line">		// console.log(elm,i,arr);</span><br><span class="line">		console.log(i);</span><br><span class="line">		return elm &gt;= 200;</span><br><span class="line">	&#125;);</span><br><span class="line">console.log(re);</span><br></pre></td></tr></table></figure>

<h1 id="字符串方法："><a href="#字符串方法：" class="headerlink" title="字符串方法："></a>字符串方法：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.trim()</span><br><span class="line">trim：删除字符串两侧的空白符</span><br></pre></td></tr></table></figure>

<h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h2><ol>
<li><p>函数声明方式function 关键字(命名函数)</p>
</li>
<li><p>函数表达式(匿名函数)【自调用函数】</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Function()   var fn = new Function(&apos;参数1&apos;,&apos;参数2&apos;..., &apos;函数体&apos;)</span><br><span class="line"></span><br><span class="line">var fn = new Function(&apos;a&apos;,&apos;b&apos;,&apos;console.log(a,b);&apos;);</span><br><span class="line">  </span><br><span class="line">fn(123,456);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Function 里面参数都必须是字符串格式</p>
</li>
<li><p>第三种方式执行效率低，也不方便书写，因此较少使用</p>
</li>
<li><p>所有函数都是Function 的实例(对象) </p>
</li>
<li><p>函数也属于对象</p>
</li>
</ol>
<h2 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a>函数的调用方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 普通函数【function fn () &#123;&#125;==&gt;fn()】</span><br><span class="line">2. 对象的方法【对象.方法名()】</span><br><span class="line">3. 构造函数【new Fn();】</span><br><span class="line">4. 绑定事件函数【btn.onclick = function () &#123;&#125;】</span><br><span class="line">5. 定时器函数【window.setInterval(function () &#123;&#125;,1000);】</span><br><span class="line">6. 立即执行函数【(function () &#123;&#125;)()】</span><br></pre></td></tr></table></figure>

<h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><p><img src="E:%5Cnewlife%5C%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6%5Cjs%E9%AB%98%E7%BA%A7%5Cjs%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0%5Cthis.bmp" alt="this"></p>
<h1 id="改变函数内部this-指向"><a href="#改变函数内部this-指向" class="headerlink" title="改变函数内部this 指向"></a>改变函数内部this 指向</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaScript 为我们专门提供了一些函数方法来帮我们更优雅的处理函数内部this 的指向问题，常用的有bind()、call()、apply() 三种方法。</span><br></pre></td></tr></table></figure>

<h2 id="call-方法"><a href="#call-方法" class="headerlink" title="call 方法"></a>call 方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">call() 方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的this 指向。</span><br><span class="line">call()只能函数调用（改变this指向，函数才有this） </span><br><span class="line">普通函数直接.call（）   </span><br><span class="line">如果是函数对象，对象.函数.call（） 函数不能调用及不能加（）</span><br><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br><span class="line">thisArg：在fun 函数运行时指定的this 值</span><br><span class="line"></span><br><span class="line">arg1，arg2：传递的其他参数</span><br><span class="line"></span><br><span class="line">返回值就是函数的返回值，因为它就是调用函数</span><br><span class="line"></span><br><span class="line">function Father () &#123;this&#125;</span><br><span class="line">function Son () &#123; Father.call(this,1,2) &#125;</span><br><span class="line"></span><br><span class="line">因此当我们想改变this 指向，同时想调用这个函数的时候，可以使用call，比如继承</span><br></pre></td></tr></table></figure>

<h2 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a>apply 方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun.apply(thisArg, [argsArray]):调用函数</span><br><span class="line"></span><br><span class="line">thisArg：在fun函数运行时指定的this值</span><br><span class="line"></span><br><span class="line">argsArray：传递的值，必须包含在数组里面</span><br><span class="line"></span><br><span class="line">返回值就是函数的返回值，因为它就是调用函数</span><br><span class="line"></span><br><span class="line">因此apply 主要跟数组有关系，比如使用Math.max() 求数组的最大值</span><br><span class="line"></span><br><span class="line">var obj = &#123;name : &apos;张三丰&apos;&#125;</span><br><span class="line">	function fn (arr，arr2) &#123;</span><br><span class="line">		console.log(this);</span><br><span class="line">		console.log(arr);</span><br><span class="line">		console.log(arr2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//#################################################</span><br><span class="line">	var arr = [23,45,56,23,54];</span><br><span class="line"></span><br><span class="line">	var n = Math.max.apply(null,arr);</span><br><span class="line"></span><br><span class="line">	console.log(n);</span><br></pre></td></tr></table></figure>

<h2 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bind()方法不会 调用函数。但是能改变函数内部this 指向</span><br><span class="line"></span><br><span class="line">fun.bind(thisArg, arg1, arg2, ...)</span><br><span class="line"></span><br><span class="line">thisArg：在fun 函数运行时指定的this 值</span><br><span class="line"></span><br><span class="line">arg1，arg2：传递的其他参数</span><br><span class="line"></span><br><span class="line">返回由指定的this 值和初始化参数改造的原函数拷贝</span><br><span class="line"></span><br><span class="line">因此当我们只是想改变this 指向，并且不想调用这个函数的时候，可以使用bind</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var btn = document.querySelector(&apos;input&apos;);</span><br><span class="line"></span><br><span class="line">		btn.onclick = function () &#123;</span><br><span class="line">			this.disabled = true;</span><br><span class="line">			window.setTimeout(function () &#123;</span><br><span class="line">				this.disabled = false;</span><br><span class="line">			&#125;.bind(btn),2000);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="call-apply-bind-总结"><a href="#call-apply-bind-总结" class="headerlink" title="call  apply  bind 总结"></a>call  apply  bind 总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun.call(obj,arg1,arg2......);</span><br><span class="line">fun.apply(obj,[a,b,c])</span><br><span class="line">fun.bind(obj,arg1,arg2......);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">相同点:  都可以改变函数内部的this指向.</span><br><span class="line"></span><br><span class="line">区别点:  </span><br><span class="line">1.call 和apply  会调用函数, 并且改变函数内部this指向.</span><br><span class="line">2.call 和apply 传递的参数不一样, call 传递参数aru1, aru2..形式apply 必须数组形式[arg]</span><br><span class="line">3.bind  不会调用函数, 可以改变函数内部this指向</span><br><span class="line"></span><br><span class="line">主要应用场景:  </span><br><span class="line">1.call 经常做继承. </span><br><span class="line">2.apply 经常跟数组有关系.比如借助于数学对象实现数组最大值最小值</span><br><span class="line">3.bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向</span><br></pre></td></tr></table></figure>

<h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>JS：两种模式[类似于HTML版本]</p>
<p>​    1、正常模式</p>
<p>​    2、严格模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">什么是严格模式</span><br><span class="line"></span><br><span class="line">JavaScript 除了提供正常模式外，还提供了严格模式（strictmode）。ES5 的严格模式是采用具有限制性JavaScript 变体的一种方式，即在严格的条件下运行JS 代码。</span><br><span class="line">严格模式在IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。</span><br><span class="line">严格模式对正常的JavaScript 语义做了一些更改：</span><br><span class="line"></span><br><span class="line">1.消除了Javascript语法的一些不合理、不严谨之处，减少了一些怪异行为。【例如变量，不声明就报错】</span><br><span class="line">2.消除代码运行的一些不安全之处，保证代码运行的安全。</span><br><span class="line">3.提高编译器效率，增加运行速度。</span><br><span class="line">4.禁用了在ECMAScript的未来版本中可能会定义的一些语法，为未来新版本的Javascript做好铺垫。比如一些保留字如：class, enum, export, extends, import, super 不能做变量名</span><br></pre></td></tr></table></figure>

<h2 id="开启严格模式"><a href="#开启严格模式" class="headerlink" title="开启严格模式"></a>开启严格模式</h2><p>开启严格模式：”use strict”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;&quot;use strict&quot;&lt;/script&gt;：脚本开启严格模式</span><br><span class="line">&lt;script&gt;function fn () &#123;&quot;use strict&quot;&#125;&lt;/script&gt;为函数开启严格模式</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">严格模式可以应用到整个脚本或个别函数中。因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。</span><br></pre></td></tr></table></figure>

<p><strong>为脚本开启严格模式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">为整个脚本文件开启严格模式，需要在所有语句之前放一个特定语句“use strict”;（或‘use strict’;）。</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	&quot;use strict&quot;;</span><br><span class="line">	console.log(&quot;这是严格模式。&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">因为&quot;use strict&quot;加了引号，所以老版本的浏览器会把它当作一行普通字符串而忽略。</span><br></pre></td></tr></table></figure>

<p><strong>为函数开启严格模式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">要给某个函数开启严格模式，需要把“use strict”;  (或&apos;use strict&apos;; ) 声明放在函数体所有语句之前。</span><br><span class="line"></span><br><span class="line">function fn()&#123;&quot;use strict&quot;;return &quot;这是严格模式。&quot;;&#125;</span><br><span class="line"></span><br><span class="line">将&quot;use strict&quot;放在函数体的第一行，则整个函数以&quot;严格模式&quot;运行。</span><br></pre></td></tr></table></figure>

<h2 id="严格模式中的变化"><a href="#严格模式中的变化" class="headerlink" title="严格模式中的变化"></a>严格模式中的变化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">严格模式对Javascript的语法和行为，都做了一些改变。</span><br></pre></td></tr></table></figure>

<p><strong>变量规定</strong></p>
<p>​    <strong>变量声明必须加var，而且不准删除变量</strong>    <strong>函数声明需要放在顶层</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，变量都必须先用var命令声明，然后再使用。</span><br><span class="line">n = 3;</span><br><span class="line">严禁删除已经声明变量。例如，delete x; 语法是错误的。</span><br></pre></td></tr></table></figure>

<p><strong>严格模式下this 指向问题</strong></p>
<p>​    <strong>严格模式下，普通函数this是undefined</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">以前在全局作用域函数中的this 指向window 对象。</span><br><span class="line">严格模式下全局作用域中函数中的this是undefined。</span><br><span class="line"></span><br><span class="line">其他的没有变化：</span><br><span class="line">以前构造函数时不加new也可以调用,当普通函数，this 指向全局对象</span><br><span class="line">严格模式下,如果构造函数不加new调用, this 指向的是undefined 如果给他赋值则会报错</span><br><span class="line">new 实例化的构造函数指向创建的对象实例。</span><br><span class="line">定时器this 还是指向window 。</span><br><span class="line">事件、对象还是指向调用者。</span><br></pre></td></tr></table></figure>

<p><strong>函数变化</strong></p>
<p>​    <strong>参数不能重名</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">函数不能有重名的参数。</span><br><span class="line"></span><br><span class="line">函数必须声明在顶层.新版本的JavaScript 会引入“块级作用域”（ES6 中已引入）。为了与新版本接轨，不允许在非函数的代码块内声明函数。【if，for等里面定义函数也不可以，但是现在不可以】</span><br><span class="line"></span><br><span class="line">更多严格模式要求参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</span><br><span class="line"></span><br><span class="line">错误写法:</span><br><span class="line">function fn (a,a) &#123;console.log(a+a);&#125;</span><br><span class="line">fn(1,2);</span><br></pre></td></tr></table></figure>

<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">此时fn就是一个高阶函数</span><br><span class="line"></span><br><span class="line">函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。</span><br><span class="line"></span><br><span class="line">同理函数也可以作为返回值传递回来</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	function fn(callback)&#123;</span><br><span class="line">		callback&amp;&amp;callback();</span><br><span class="line">	&#125;</span><br><span class="line">	fn(function()&#123;</span><br><span class="line">		alert(&apos;hi&apos;)</span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	function fn()&#123;</span><br><span class="line">		return function() &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fn();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">变量根据作用域的不同分为两种：全局变量和局部变量。</span><br><span class="line"></span><br><span class="line">1. 函数内部可以使用全局变量。</span><br><span class="line">2. 函数外部不可以使用局部变量。</span><br><span class="line">3. 当函数执行完毕，本作用域内的局部变量会销毁。</span><br></pre></td></tr></table></figure>

<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a><strong>什么是闭包</strong></h2><p>官方解释：闭包是指有权访问另一个 函数作用域中的变量的函数。创建闭包的常见方式,就是在一个函数内部创建另一个函数</p>
<p>白话解释：<strong>闭包是一种特殊的对象。 它由两部分组成。执行上下文(代号A)，以及在该执行上下文中创建的函数（代号B）。 当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。</strong></p>
<p>闭包作用：延伸变量的作用范围。**</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">闭包（closure）指有权访问另一个函数作用域中变量的函数。【很多种解释，都并不权威】</span><br><span class="line"></span><br><span class="line">简单理解就是，一个作用域可以访问另外一个函数内部的局部变量。</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	function fn1()&#123;</span><br><span class="line">		// fn1 就是闭包函数</span><br><span class="line">		var num = 10;</span><br><span class="line">		function fn2()&#123;</span><br><span class="line">			console.log(num); // 10</span><br><span class="line">		&#125;</span><br><span class="line">		fn2()</span><br><span class="line">	&#125;</span><br><span class="line">	fn1();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>思考：如何再函数外面访问到函数内部的变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fn () &#123;</span><br><span class="line"></span><br><span class="line">		var i = 7;</span><br><span class="line">		return function () &#123;  //返回函数</span><br><span class="line">			console.log(i);</span><br><span class="line">		&#125;</span><br><span class="line">		// function fn1 () &#123;</span><br><span class="line">		// 	console.log(i);</span><br><span class="line">		// &#125;</span><br><span class="line">		// fn1();</span><br><span class="line">	&#125;</span><br><span class="line">	var n = fn(); // n=return function () &#123;console.log(i);&#125;</span><br><span class="line">fn();//不调用 局部变量n永远在</span><br></pre></td></tr></table></figure>

<p><strong>练习：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">注册事件练习：打印索引值</span><br><span class="line">var lis = document.querySelectorAll(&apos;li&apos;);</span><br><span class="line"></span><br><span class="line">	for (var i = 0; i &lt; lis.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">		(function (index) &#123;</span><br><span class="line">			lis[index].onclick = function () &#123;</span><br><span class="line">				console.log(index);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">递归：**如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己, 这个函数就是递归函数</span><br><span class="line"></span><br><span class="line">递归：是最先触发的元素</span><br><span class="line"></span><br><span class="line">**注意：**递归函数的作用和循环效果一样，由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件return。</span><br></pre></td></tr></table></figure>

<h2 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">利用递归求1~n的阶乘</span><br><span class="line"></span><br><span class="line">//利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..n</span><br><span class="line"> function fn(n) &#123;</span><br><span class="line">     if (n == 1) &#123; //结束条件</span><br><span class="line">       return 1;</span><br><span class="line">     &#125;</span><br><span class="line">     return n * fn(n - 1);</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(fn(3));</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">利用递归求斐波那契数列</span><br><span class="line"></span><br><span class="line">// 利用递归函数求斐波那契数列(兔子序列)  1、1、2、3、5、8、13、21...</span><br><span class="line">// 用户输入一个数字 n 就可以求出 这个数字对应的兔子序列值</span><br><span class="line">// 我们只需要知道用户输入的n 的前面两项(n-1 n-2)就可以计算出n 对应的序列值</span><br><span class="line">function fb(n) &#123;</span><br><span class="line">  if (n === 1 || n === 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return fb(n - 1) + fb(n - 2);</span><br><span class="line">&#125;</span><br><span class="line">console.log(fb(3));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">羊村：50人家，每户一只羊</span><br><span class="line">	每户只能看别人家的羊有木有病</span><br><span class="line">	每户只能杀自己家的羊</span><br><span class="line">	第一天，第二天 ,第三天，砰砰砰几声枪响，问杀了几只羊 3只</span><br><span class="line">	///////////////////////////////////////////////////////</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line">   if (num &lt;= 1)&#123;</span><br><span class="line">       return 1;</span><br><span class="line">   &#125; else &#123; </span><br><span class="line">       return num * factorial(num-1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">var anotherFactorial = factorial; </span><br><span class="line">factorial = null;</span><br><span class="line">alert(anotherFactorial(4));	//报错 因为factorial已不是一个函数</span><br><span class="line">防止调用途中factorial被改变</span><br><span class="line">function factorial(num)&#123;</span><br><span class="line">    if (num &lt;= 1)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num * arguments.callee(num-1);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">var anotherFactorial = factorial; </span><br><span class="line">factorial = null;</span><br><span class="line">alert(anotherFactorial(4));</span><br><span class="line">//但在严格模式下,不能通过脚本访问 arguments.callee,访问这个属性会导致错误</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">利用递归遍历数据</span><br><span class="line"></span><br><span class="line">		var data = [</span><br><span class="line">			&#123;</span><br><span class="line">				id : 1,</span><br><span class="line">				name : &apos;家电&apos;</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				id : 2,</span><br><span class="line">				name : &apos;服饰&apos;</span><br><span class="line">			&#125;</span><br><span class="line">		];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var data = [&#123;</span><br><span class="line">   id: 1,</span><br><span class="line">   name: &apos;家电&apos;,</span><br><span class="line">   goods: [&#123;</span><br><span class="line">     id: 11,</span><br><span class="line">     gname: &apos;冰箱&apos;,</span><br><span class="line">     goods: [&#123;</span><br><span class="line">       id: 111,</span><br><span class="line">       gname: &apos;海尔&apos;</span><br><span class="line">     &#125;, &#123;</span><br><span class="line">       id: 112,</span><br><span class="line">       gname: &apos;美的&apos;</span><br><span class="line">     &#125;,</span><br><span class="line"></span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">   &#125;, &#123;</span><br><span class="line">     id: 12,</span><br><span class="line">     gname: &apos;洗衣机&apos;</span><br><span class="line">   &#125;]</span><br><span class="line"> &#125;, &#123;</span><br><span class="line">   id: 2,</span><br><span class="line">   name: &apos;服饰&apos;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"> function getID (data,id) &#123;</span><br><span class="line">            // data要查询数据的数组</span><br><span class="line">            var obj = &#123;&#125;;</span><br><span class="line">            //遍历</span><br><span class="line">            data.forEach(function(ele)&#123;</span><br><span class="line">                console.log(ele)</span><br><span class="line">                if(ele.id=id)&#123;</span><br><span class="line">                    obj=ele;</span><br><span class="line">                &#125;else if(ele.goods&amp;&amp;ele.goods.length&gt;0)&#123;</span><br><span class="line">                    obj=getID(ele.goods,id);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            return obj;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        console.log(getID(data,111));</span><br></pre></td></tr></table></figure>

<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>​    <strong>拷贝不能直接赋值，对象赋值的是地址</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">		name : &apos;张三丰&apos;,</span><br><span class="line">		age : 22</span><br><span class="line">	&#125;;</span><br><span class="line">var newObj = obj;</span><br><span class="line">console.log(newObj);</span><br></pre></td></tr></table></figure>

<h3 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h3><blockquote>
<p>只拷贝最外面一层</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">			name : &apos;张三丰&apos;,</span><br><span class="line">			age : 22</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		var newObj = &#123;&#125;;</span><br><span class="line">		for (key in obj) &#123;</span><br><span class="line">			newObj[key] = obj[key];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		console.log(newObj);</span><br><span class="line">		</span><br><span class="line">es6：新方法</span><br><span class="line">Object.assign(target, sources);</span><br><span class="line"></span><br><span class="line">console.log(newObj);</span><br></pre></td></tr></table></figure>

<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">			name : &apos;1张三丰&apos;,</span><br><span class="line">			age : 22,</span><br><span class="line">			messige : &#123;</span><br><span class="line">				sex : &apos;男&apos;,</span><br><span class="line">				score : 16</span><br><span class="line">			&#125;,</span><br><span class="line">			color : [&apos;red&apos;,&apos;purple&apos;,&apos;qing&apos;]</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		var newObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		function kaobei (newObj,obj) &#123;</span><br><span class="line"></span><br><span class="line">			for (key in obj) &#123;</span><br><span class="line"></span><br><span class="line">				if (obj[key] instanceof Array) &#123;</span><br><span class="line">					newObj[key] = [];</span><br><span class="line">					kaobei(newObj[key],obj[key]);</span><br><span class="line">				&#125; else if (obj[key] instanceof Object) &#123;</span><br><span class="line">					newObj[key] = &#123;&#125;;</span><br><span class="line">					kaobei(newObj[key],obj[key])</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					newObj[key] = obj[key];</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		obj.messige.sex = 99;</span><br><span class="line">		kaobei(newObj,obj);</span><br><span class="line">		console.log(newObj);</span><br></pre></td></tr></table></figure>

<h1 id="正则表达式概述"><a href="#正则表达式概述" class="headerlink" title="正则表达式概述"></a>正则表达式概述</h1><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。</span><br><span class="line"></span><br><span class="line">作用：检索关键字，过滤敏感字符，表单验证</span><br><span class="line"></span><br><span class="line">正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配)。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。</span><br><span class="line"></span><br><span class="line">其他语言也会使用正则表达式，本阶段我们主要是利用JavaScript 正则表达式完成表单验证。</span><br></pre></td></tr></table></figure>

<h2 id="正则表达式的特点"><a href="#正则表达式的特点" class="headerlink" title="正则表达式的特点"></a>正则表达式的特点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 灵活性、逻辑性和功能性非常的强。</span><br><span class="line">2. 可以迅速地用极简单的方式达到字符串的复杂控制。</span><br><span class="line">3. 对于刚接触的人来说，比较晦涩难懂。比如：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$</span><br><span class="line">4. 实际开发,一般都是直接复制写好的正则表达式. 但是要求会使用正则表达式并且根据实际情况修改正则表达式.   比如用户名:   /^[a-z0-9_-]&#123;3,16&#125;$/</span><br></pre></td></tr></table></figure>

<h2 id="正则表达式在js中的使用"><a href="#正则表达式在js中的使用" class="headerlink" title="正则表达式在js中的使用"></a>正则表达式在js中的使用</h2><p><strong>创建正则表达式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在 JavaScript 中，可以通过两种方式创建一个正则表达式。</span><br><span class="line"></span><br><span class="line">方式一：通过调用RegExp对象的构造函数创建 </span><br><span class="line"></span><br><span class="line">    var regexp = new RegExp(/123/);</span><br><span class="line">    console.log(regexp);</span><br><span class="line"></span><br><span class="line">方式二：利用字面量创建 正则表达式</span><br><span class="line"></span><br><span class="line">     var rg = /abc/; 含义：只要包含abc就可以</span><br></pre></td></tr></table></figure>

<h2 id="测试正则表达式"><a href="#测试正则表达式" class="headerlink" title="测试正则表达式"></a>测试正则表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串</span><br><span class="line"></span><br><span class="line">注意正则里面没有引号</span><br><span class="line">regexObj.test(str);</span><br><span class="line">regexObj：正则表达式</span><br><span class="line">str：用户输入字符串</span><br><span class="line"></span><br><span class="line">var rg = /123/;</span><br><span class="line">console.log(rg.test(123));//匹配字符中是否出现123  出现结果为true</span><br><span class="line">console.log(rg.test(&apos;abc&apos;));//匹配字符中是否出现123 未出现结果为false</span><br></pre></td></tr></table></figure>

<h2 id="正则表达式中的特殊字符"><a href="#正则表达式中的特殊字符" class="headerlink" title="正则表达式中的特殊字符"></a>正则表达式中的特殊字符</h2><h3 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如 /ab*c/ 。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。</span><br><span class="line"></span><br><span class="line">正则表达式：简单字符 和 特殊字符【元字符】</span><br><span class="line"></span><br><span class="line">特殊字符非常多，可以参考： </span><br><span class="line"></span><br><span class="line">MDN：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jQuery 手册：正则表达式部分</span><br><span class="line"></span><br><span class="line">正则测试工具 ： http://tool.oschina.net/regex</span><br></pre></td></tr></table></figure>

<p>正则：匹配字符串</p>
<p>​    1、创建珍珠铬【new RegExp(/abc/)，var str = /abc/;】</p>
<p>​    2、测试【reg.test(str)】</p>
<p>​    3、表达式：简单字符和特殊字符</p>
<h1 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a>边界符</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符</span><br><span class="line"></span><br><span class="line">^ : 表示匹配行首的文本（以谁开始）【/^abc/：以abc为开头】</span><br><span class="line"></span><br><span class="line">$：表示匹配行尾的文本（以谁结束）【/^abc$/：只能是abc】</span><br></pre></td></tr></table></figure>

<p><strong>如果 ^和 $ 在一起，表示必须是精确匹配。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var rg = /abc/; // 正则表达式里面不需要加引号 不管是数字型还是字符串型</span><br><span class="line">// /abc/ 只要包含有abc这个字符串返回的都是true</span><br><span class="line">console.log(rg.test(&apos;abc&apos;));</span><br><span class="line">console.log(rg.test(&apos;abcd&apos;));</span><br><span class="line">console.log(rg.test(&apos;aabcd&apos;));</span><br><span class="line">console.log(&apos;---------------------------&apos;);</span><br><span class="line">var reg = /^abc/;</span><br><span class="line">console.log(reg.test(&apos;abc&apos;)); // true</span><br><span class="line">console.log(reg.test(&apos;abcd&apos;)); // true</span><br><span class="line">console.log(reg.test(&apos;aabcd&apos;)); // false</span><br><span class="line">console.log(&apos;---------------------------&apos;);</span><br><span class="line">var reg1 = /^abc$/; // 精确匹配 要求必须是 abc字符串才符合规范</span><br><span class="line">console.log(reg1.test(&apos;abc&apos;)); // true</span><br><span class="line">console.log(reg1.test(&apos;abcd&apos;)); // false</span><br><span class="line">console.log(reg1.test(&apos;aabcd&apos;)); // false</span><br><span class="line">console.log(reg1.test(&apos;abcabc&apos;)); // false</span><br></pre></td></tr></table></figure>

<h1 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h1><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="方括号"><a href="#方括号" class="headerlink" title="[] 方括号"></a>[] 方括号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">表示有一系列字符可供选择，只要匹配其中一个就可以了【多选1】</span><br><span class="line"></span><br><span class="line">var rg = /[abc]/; // 只要包含有a 或者 包含有b 或者包含有c 都返回为true</span><br><span class="line">console.log(rg.test(&apos;andy&apos;));//true</span><br><span class="line">console.log(rg.test(&apos;baby&apos;));//true</span><br><span class="line">console.log(rg.test(&apos;color&apos;));//true</span><br><span class="line">console.log(rg.test(&apos;red&apos;));//false</span><br><span class="line">var rg1 = /^[abc]$/; // 三选一 只有是a 或者是 b  或者是c 这三个字母才返回 true</span><br><span class="line">console.log(rg1.test(&apos;aa&apos;));//false</span><br><span class="line">console.log(rg1.test(&apos;a&apos;));//true</span><br><span class="line">console.log(rg1.test(&apos;b&apos;));//true</span><br><span class="line">console.log(rg1.test(&apos;c&apos;));//true</span><br><span class="line">console.log(rg1.test(&apos;abc&apos;));//true</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">var reg = /^[a-z]$/ //26个英文字母任何一个字母返回 true  - 表示的是a 到z 的范围  </span><br><span class="line">console.log(reg.test(&apos;a&apos;));//true</span><br><span class="line">console.log(reg.test(&apos;z&apos;));//true</span><br><span class="line">console.log(reg.test(&apos;A&apos;));//false</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">//字符组合</span><br><span class="line">var reg1 = /^[a-zA-Z0-9]$/; // 26个英文字母(大写和小写都可以)任何一个字母返回 true  </span><br><span class="line">------------------------------------------------------------------------------------</span><br><span class="line">//取反 方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 。</span><br><span class="line">var reg2 = /^[^a-zA-Z0-9]$/;</span><br><span class="line">console.log(reg2.test(&apos;a&apos;));//false</span><br><span class="line">console.log(reg2.test(&apos;B&apos;));//false</span><br><span class="line">console.log(reg2.test(8));//false</span><br><span class="line">console.log(reg2.test(&apos;!&apos;));//true</span><br><span class="line"></span><br><span class="line">/^[^a-z]$/：两个^，括号外面的是便边界，括号里面的是取反的含义</span><br></pre></td></tr></table></figure>

<h2 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h2><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 词符用来设定某个模式出现的次数。</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">量词		说明</span><br><span class="line"></span><br><span class="line">*		重复0次或更多次【&gt;=0次】/^[a-z]*$/</span><br><span class="line"></span><br><span class="line">+		重复1次或更多次【&gt;=1次】【/^[a-z]+$/】</span><br><span class="line"></span><br><span class="line">?		重复0次或1次</span><br><span class="line"></span><br><span class="line">&#123;n&#125;		重复n次</span><br><span class="line"></span><br><span class="line">&#123;n,&#125;	重复n次或更多次</span><br><span class="line"></span><br><span class="line">&#123;n,m&#125;	重复n到m次</span><br><span class="line">注意：&#123;n,m&#125;n和m之间不准有空格</span><br></pre></td></tr></table></figure>

<h2 id="用户名表单验证"><a href="#用户名表单验证" class="headerlink" title="用户名表单验证"></a>用户名表单验证</h2><p>功能需求:</p>
<ol>
<li>如果用户名输入合法, 则后面提示信息为:  用户名合法,并且颜色为绿色</li>
<li>如果用户名输入不合法, 则后面提示信息为:  用户名不符合规范, 并且颜色为红色</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var input = document.querySelector(&apos;input&apos;);</span><br><span class="line">		var span = document.querySelector(&apos;span&apos;);</span><br><span class="line"></span><br><span class="line">		var reg = /^[a-zA-Z0-9_-]&#123;6,16&#125;$/;</span><br><span class="line"></span><br><span class="line">		input.onblur = function () &#123;</span><br><span class="line"></span><br><span class="line">			if (reg.test(this.value)) &#123;</span><br><span class="line">				span.innerHTML = &apos;输入正确&apos;;</span><br><span class="line">				span.className = &apos;right&apos;;</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				span.innerHTML = &apos;错误内容&apos;;</span><br><span class="line">				span.className = &apos;error&apos;;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="括号总结"><a href="#括号总结" class="headerlink" title="括号总结"></a>括号总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.大括号  量词符.  里面表示重复次数</span><br><span class="line"></span><br><span class="line">2.中括号 字符集合。匹配方括号中的任意字符. </span><br><span class="line"></span><br><span class="line">3.小括号表示优先级</span><br><span class="line"></span><br><span class="line">正则表达式在线测试 ： https://c.runoob.com</span><br></pre></td></tr></table></figure>

<h1 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">预定义类指的是某些常见模式的简写方式.</span><br></pre></td></tr></table></figure>

<img src="E:/newlife/progress/js%E9%AB%98%E7%BA%A7/day4/day4/day4/%E7%AC%94%E8%AE%B04/img3.png">

<h2 id="验证案例："><a href="#验证案例：" class="headerlink" title="验证案例："></a>验证案例：</h2><p><strong>手机验证</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var tel = document.getElementById(&apos;tel&apos;);</span><br><span class="line">var regtel = /^[1][3|4|5|7|8][0-9]&#123;9&#125;$/;</span><br><span class="line">tel.onblur = function () &#123;</span><br><span class="line"></span><br><span class="line">	if (regtel.test(tel.value)) &#123;</span><br><span class="line">		this.nextElementSibling.className = &apos;success&apos;;</span><br><span class="line">		this.nextElementSibling.innerHTML = &apos;手机输入正确&lt;i class=&quot;success_icon&quot;&gt;&lt;/i&gt;&apos;;</span><br><span class="line">		console.log(123);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		tel.nextElementSibling.className = &apos;error&apos;;</span><br><span class="line">		tel.nextElementSibling.innerHTML = &apos;手机输入错误&lt;i class=&quot;error_icon&quot;&gt;&lt;/i&gt;&apos;;</span><br><span class="line">		console.log(456)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>QQ验证：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var regqq = /^[1-9][0-9]&#123;4,&#125;$/;</span><br><span class="line"></span><br><span class="line">var regtel = /^1[3|4|5|7|8][0-9]&#123;9&#125;$/;</span><br><span class="line">	var regqq = /^[1-9][0-9]&#123;4,&#125;$/;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	function jiance (obj, reg) &#123;</span><br><span class="line">		obj.onblur = function () &#123;</span><br><span class="line">			if (reg.test(this.value)) &#123;</span><br><span class="line">				this.nextElementSibling.className = &apos;success&apos;;</span><br><span class="line">				this.nextElementSibling.innerHTML = &apos;&lt;i class=&quot;success_icon&quot;&gt;&lt;/i&gt; 手机输入正确&apos;;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				this.nextElementSibling.className = &apos;error&apos;;</span><br><span class="line">				this.nextElementSibling.innerHTML = &apos;&lt;i class=&quot;error_icon&quot;&gt;&lt;/i&gt; 手机输入错误&apos;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	jiance(tel,regtel);</span><br><span class="line">	jiance(qq,regqq);</span><br></pre></td></tr></table></figure>

<p><strong>昵称验证：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var nikName = /^[\u4e00-\u9fa5]&#123;2,8&#125;$/;</span><br></pre></td></tr></table></figure>

<p><strong>短信验证：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regmsg = /^[0-9]&#123;6&#125;$/;</span><br></pre></td></tr></table></figure>

<h2 id="replace替换："><a href="#replace替换：" class="headerlink" title="replace替换："></a>replace替换：</h2><p>/表达式/[修饰符]</p>
<p>g：全局匹配</p>
<p>i：忽略大小写</p>
<p>gi：全局+忽略</p>
<p>屏蔽敏感字符</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/20/js-node/" data-id="ck0scf88x000580rsb2sysn5c"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js-node/">js-node</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        

<article id="post-hexo搭建步骤" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/09/20/hexo搭建步骤/">hexo搭建步骤</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/09/20/hexo搭建步骤/" class="article-date">
  <time datetime="2019-09-20T09:15:29.000Z" itemprop="datePublished">2019-09-20</time>
</a>
        
      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <h3 id="1-1-安装hexo"><a href="#1-1-安装hexo" class="headerlink" title="1-1  安装hexo"></a>1-1  安装hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g // -g 代表的是全局下安装</span><br></pre></td></tr></table></figure>

<h3 id="1-2-创建blog文件夹-博客根目录"><a href="#1-2-创建blog文件夹-博客根目录" class="headerlink" title="1-2  创建blog文件夹,博客根目录"></a>1-2  创建blog文件夹,博客根目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:blog // 不推荐中文路径,在当前目录打开cmd窗口</span><br></pre></td></tr></table></figure>

<h3 id="1-3-切换到根目录盘符-初始化"><a href="#1-3-切换到根目录盘符-初始化" class="headerlink" title="1-3  切换到根目录盘符,初始化"></a>1-3  切换到根目录盘符,初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init // 初始化文件</span><br></pre></td></tr></table></figure>

<h3 id="1-4-在github创建仓库-用来存放项目"><a href="#1-4-在github创建仓库-用来存放项目" class="headerlink" title="1-4  在github创建仓库,用来存放项目"></a>1-4  在github创建仓库,用来存放项目</h3><ul>
<li>新创建一个仓库,但是地址名称一定要遵循这种格式,否则会失败</li>
</ul>
<h3 id="1-5-配置Pages信息"><a href="#1-5-配置Pages信息" class="headerlink" title="1-5 配置Pages信息"></a>1-5 配置Pages信息</h3><ul>
<li>要选中一个模板,才能通过外网访问这个地址名称的blog</li>
<li>在settings中去找这个配置项去</li>
</ul>
<h3 id="1-6-在blog目录下进行配置关联"><a href="#1-6-在blog目录下进行配置关联" class="headerlink" title="1-6 在blog目录下进行配置关联"></a>1-6 在blog目录下进行配置关联</h3><ul>
<li>可以使用记事本打开这个文件,也可以直接使用编辑器打开进行后续的编辑</li>
</ul>
<h3 id="1-7-打开-config-yml文件进行地址绑定"><a href="#1-7-打开-config-yml文件进行地址绑定" class="headerlink" title="1-7 打开_config.yml文件进行地址绑定"></a>1-7 打开_config.yml文件进行地址绑定</h3><ul>
<li>需要在本地的配置文件中,绑定上你远程仓库的地址名称,并且一定要注意格式问题</li>
</ul>
<h3 id="1-8-安装deploter-git插件"><a href="#1-8-安装deploter-git插件" class="headerlink" title="1-8 安装deploter-git插件"></a>1-8 安装deploter-git插件</h3><ul>
<li>npm install hexo-deployer-git</li>
<li>在命令行中,输入此行命令,等待下载完成即可</li>
</ul>
<h3 id="1-9-安装cname插件"><a href="#1-9-安装cname插件" class="headerlink" title="1-9 安装cname插件"></a>1-9 安装cname插件</h3><ul>
<li>npm install hexo-generator-cname</li>
<li>在命令行中,输入此命令,等待下载完成,可以直接复制此行命令,以免拼写错误</li>
</ul>
<h3 id="2-0-部署成功-访问地址查看"><a href="#2-0-部署成功-访问地址查看" class="headerlink" title="2-0 部署成功,访问地址查看"></a>2-0 部署成功,访问地址查看</h3><ul>
<li>看到以下的提示信息,就代表整个blog上传成功了</li>
<li>hexo g</li>
<li>hexo d</li>
</ul>
<h3 id="2-1-通过https-zhaoyi-1-9部署成功ran1988-github-io访问"><a href="#2-1-通过https-zhaoyi-1-9部署成功ran1988-github-io访问" class="headerlink" title="2-1 通过https://zhaoyi!1-9部署成功ran1988.github.io访问"></a>2-1 通过<a href="https://zhaoyi!" target="_blank" rel="noopener">https://zhaoyi!</a><a href="images/1-9%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F.jpg">1-9部署成功</a>ran1988.github.io访问</h3><ul>
<li>验证可以通过外网的方式,访问到自己的blog,默认就是如图的主题</li>
</ul>
<h3 id="2-2-更换默认主题-官方主题地址-https-hexo-io-themes"><a href="#2-2-更换默认主题-官方主题地址-https-hexo-io-themes" class="headerlink" title="2-2  更换默认主题-官方主题地址:https://hexo.io/themes/"></a>2-2  更换默认主题-官方主题地址:<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></h3><ul>
<li>可以根据自己的喜好,来选择主题,主题都会存放到github的仓库中,所以直接使用clone命令下载就行</li>
</ul>
<h3 id="2-3-下载主题"><a href="#2-3-下载主题" class="headerlink" title="2-3 下载主题"></a>2-3 下载主题</h3><ul>
<li>需要在blog根文件夹中的themes文件夹中,打开命令行</li>
</ul>
<h3 id="2-4-配置主题"><a href="#2-4-配置主题" class="headerlink" title="2-4 配置主题"></a>2-4 配置主题</h3><ul>
<li>需要注意theme: 中的空格,否则会上传新主题失败</li>
</ul>
<h3 id="2-5-上传新的主题"><a href="#2-5-上传新的主题" class="headerlink" title="2-5 上传新的主题"></a>2-5 上传新的主题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 配置成功后,输入命令,hexo g</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- hexo d等待上传新的主题</span><br></pre></td></tr></table></figure>

<h3 id="2-6-上传主题成功"><a href="#2-6-上传主题成功" class="headerlink" title="2-6 上传主题成功"></a>2-6 上传主题成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 上传服务器后,会有延迟,所以需要多次强制刷新,才可以显示出新的主题</span><br></pre></td></tr></table></figure>

<h3 id="2-7-创建新文章-并且上传到blog中"><a href="#2-7-创建新文章-并且上传到blog中" class="headerlink" title="2-7 创建新文章,并且上传到blog中"></a>2-7 创建新文章,并且上传到blog中</h3><ul>
<li><p>部署以及更换完主题后,将我们平时总结的文章部署到自己的blog中</p>
</li>
<li><p>在提示的路径中,找到刚创建好的文件,打开文件书写内容时需要注意tags:中的格式,否则会导致上传文章失败</p>
</li>
</ul>
<h3 id="2-8-创建新文章后-把文章部署到blog中"><a href="#2-8-创建新文章后-把文章部署到blog中" class="headerlink" title="2-8 创建新文章后,把文章部署到blog中"></a>2-8 创建新文章后,把文章部署到blog中</h3><ul>
<li>上传文章,也是需要刷新的,需要耐心等待</li>
<li>在当前文档打开运行,shift+右键,</li>
<li>hexo new 文件名</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/20/hexo搭建步骤/" data-id="ck0scf87l000180rslymwhii9"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo搭建/">hexo搭建</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        

<article id="post-git-note" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/09/20/git-note/">git-note</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/09/20/git-note/" class="article-date">
  <time datetime="2019-09-20T07:27:02.000Z" itemprop="datePublished">2019-09-20</time>
</a>
        
      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <h1 id="git-笔记"><a href="#git-笔记" class="headerlink" title="git 笔记"></a>git 笔记</h1><h2 id="git基本介绍"><a href="#git基本介绍" class="headerlink" title="git基本介绍"></a>git基本介绍</h2><p>作用：</p>
<ul>
<li>管理历史记录</li>
<li>多人合作</li>
</ul>
<p>分布式版本管理软件</p>
<h2 id="git-bash的基本使用"><a href="#git-bash的基本使用" class="headerlink" title="git-bash的基本使用"></a>git-bash的基本使用</h2><ul>
<li>启动</li>
<li>关闭</li>
<li>命令<ul>
<li>mkdir 创建目录</li>
<li>cd 切换目录</li>
<li>ls 查看目录</li>
<li>ls -a 查看目录，包含隐藏目录</li>
<li>touch  新建文件 </li>
<li>rm 删除文件 </li>
<li>clear 清屏</li>
<li>cat 查看文件内容</li>
<li>方向键：切换历史命令</li>
<li>tab: 补全</li>
</ul>
</li>
</ul>
<h2 id="git的基本流程"><a href="#git的基本流程" class="headerlink" title="git的基本流程"></a>git的基本流程</h2><ul>
<li><ol>
<li>初始git仓库</li>
</ol>
<ul>
<li><code>git init</code></li>
<li>自动创建一个隐藏目录”.git”</li>
</ul>
</li>
</ul>
<ul>
<li><ol>
<li>把文件添加到git</li>
</ol>
<ul>
<li>git add 文件名.后缀名</li>
</ul>
</li>
<li><ol>
<li>提交本次修改</li>
</ol>
<ul>
<li>git commit -m  “提交说明”</li>
<li>如果是第一次提交，还要设置邮箱和用户名</li>
</ul>
</li>
<li><ol>
<li>重复2,3,4</li>
<li>通过git log来观察每次的提交信息。</li>
</ol>
</li>
</ul>
<h2 id="git三个工作区域"><a href="#git三个工作区域" class="headerlink" title="git三个工作区域"></a>git三个工作区域</h2><ul>
<li>工作区<ul>
<li>用户操作文件的区域</li>
</ul>
</li>
<li>暂存区<ul>
<li>运行<code>git add 文件名</code>  。 把对<strong>文件的修改</strong>加入暂存区</li>
</ul>
</li>
<li>仓库<ul>
<li>运行 <code>git  commit -m &quot;提交说明&quot;</code> 。把暂存区的内容，放入仓库 ，产生新版本。</li>
</ul>
</li>
</ul>
<h2 id="git文件的四种状态"><a href="#git文件的四种状态" class="headerlink" title="git文件的四种状态"></a>git文件的四种状态</h2><ul>
<li>未跟踪（Untracked）。这个文件对于git来说是新的。从来没有add过。git不会对它进行文件管理。</li>
<li>已暂存。通过add命令。<ul>
<li>git add 文件名</li>
<li>git add .   // 添加全部文件</li>
</ul>
</li>
<li>已提交。通过commit命令。<ul>
<li>git commit -m “提交说明” 。 产生一个新的版本。</li>
</ul>
</li>
<li>已修改。提交commit之后，再次编辑了这个文件。</li>
</ul>
<h2 id="git的后悔药"><a href="#git的后悔药" class="headerlink" title="git的后悔药"></a>git的后悔药</h2><ul>
<li><p>只在工作区修改了，但没有add。</p>
<ul>
<li><code>git checkout -- filename.txt</code></li>
</ul>
</li>
<li><p>工作区修改了，也add了，到了暂存区。</p>
<ul>
<li>git reset HEAD filename.txt</li>
<li>git checkout – filename.txt</li>
</ul>
</li>
<li><p>add,commit之后，就进入仓库</p>
<p>从仓库中恢复：</p>
<ul>
<li>知道commitID . <code>git log --oneline</code></li>
<li>恢复某一个文件  ： git checkout commitID filename.txt</li>
<li>整体恢复：git reset –hard commitID </li>
<li>注意：通过 git status ,检查是否干净”nothing to commit, working tree clean”，如果不是，需要再次commit。</li>
</ul>
</li>
</ul>
<h2 id="git分支管理"><a href="#git分支管理" class="headerlink" title="git分支管理"></a>git分支管理</h2><ul>
<li>git init 就有master分支</li>
<li>命令<ul>
<li>git branch 分支名 ： 创建分支</li>
<li>git checkout 分支名： 切换已有的分支</li>
<li>git checkout -b dev； 创建并切换分支 dev</li>
</ul>
</li>
<li>一个分支中<strong>添加</strong>的文件，在另一个分支不能看见的。</li>
</ul>
<h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>为什么建立分支：不影响旧代码的基础去实现新的功能。</p>
<p>为什么要合并分支：新的功能已经通过的检测，验证没有问题。要把这个新的功能补充到旧的代码中去。就要合并分支。</p>
<p><code>git merge 分支</code>： 把指定分支合并到当前的分支。</p>
<ul>
<li>master 分支不做开发。只用来merge。</li>
<li>开发建立dev分支。如果新功能也要合并到master.</li>
<li>修复bug，从master拉一个新的分支（一般会用bug12132命名），修复bug结束，切回master，从master去merge dug分支。</li>
</ul>
<h2 id="git合并分支时的冲突"><a href="#git合并分支时的冲突" class="headerlink" title="git合并分支时的冲突"></a>git合并分支时的冲突</h2><ul>
<li>多个分支修改了相同的文件，无法自动合并。</li>
<li>手动解决冲突<ul>
<li>解决冲突之后，要<ul>
<li>add</li>
<li>commit</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="git使用分支的基本流程"><a href="#git使用分支的基本流程" class="headerlink" title="git使用分支的基本流程"></a>git使用分支的基本流程</h2><p>在项目开发过程中，我们至少会接触三个分支：</p>
<ul>
<li><p>名为master的主分支</p>
<p>master分支表示稳定的，可以正常运行的主分支。在我们初始化git时，它就会自动被创建。</p>
</li>
<li><p>名为dev的开发分支</p>
<p>开发中，我们一般会新建一个名为 dev的分支(dev是development的简写，表示开发)，在这个基础上进行开发，测试，然后合并到master分支上。当然了，名字也不一定必须是dev。</p>
</li>
<li><p>名为bug的临时分支。bug解决完成之后，合并到master，再删除bug这个分支。</p>
</li>
</ul>
<h2 id="github基本操作"><a href="#github基本操作" class="headerlink" title="github基本操作"></a>github基本操作</h2><ul>
<li><p>创建一个仓库</p>
</li>
<li><p>clone 到本地</p>
<p><code>git clone  https://github.com/yanwanpeng666/learngit.git</code></p>
</li>
<li><p>本地正常操作</p>
<ul>
<li>git add </li>
<li>git commit</li>
</ul>
</li>
<li><p>同步到github</p>
</li>
<li><p>git push(是否有权限)</p>
</li>
<li><p>从远程github拉取代码</p>
<ul>
<li>git pull</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/20/git-note/" data-id="ck0scf87e000080rsb0312c8q"
         class="article-share-link">Share</a>
      
    </footer>

  </div>

  

  

</article>



      
        

<article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/09/19/hello-world/">Hello World</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/09/19/hello-world/" class="article-date">
  <time datetime="2019-09-19T04:11:08.142Z" itemprop="datePublished">2019-09-19</time>
</a>
        
      </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/09/19/hello-world/" data-id="ck0scf87p000280rsaqaf2u9r"
         class="article-share-link">Share</a>
      
    </footer>

  </div>

  

  

</article>



      
  </article>
  

  
</section>
</div>

  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2019 Hexo</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>

  <aside class="sidebar">
    
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Hexo"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/ocean.js"></script>

</body>
</html>